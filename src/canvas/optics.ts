/* This module handles the calculations of which ray segments should appear in the scene, given the locations
of light sources and objects. */

import {
    newPoint,
    vec_add,
    vec_dot,
    vec_mul,
    vec_normalize,
    vec_sub,
    type Vec3,
} from "../math";
import type { Intersection, Shape } from "../shapes";
import type { Color } from "../shared/color";
import { apply } from "../transform";
import type { Laser, Ray } from "../types";

export interface RaySegment {
    start: Vec3;
    end: Vec3;
    color: Color;
}

/**
 * Returns all ray segments generated by the given laser.
 * This amounts to traversing a tree:
 * - The root node represents the laser source
 * - Leaf nodes represent the infinitely distant endpoints of segments that don't hit any shape
 * - All intermediate nodes represent the intersection of a segment with some shape in the scene.
 * It's a tree, not a list, because when a beam hits a surface it will typically generate (at least) one reflected
 * ray and (at least) one refracted ray, depending on the material properties.
 * Each edge (segment) needs to be appended to the return array. Its color depends on the color of its child edges,
 * and on the material properties of its child node (intersection point).
 * We avoid a recursive implementation because that would not translate well to a GPU version.
 *
 * Instead, we do two passes:
 * In pass 1, we generate the tree, moving downwards from the root node.
 * ... More to work out!
 * @param laser
 * @param shapes
 * @returns
 */
function _computeSegments(
    laser: Laser,
    shapes: Shape[],
    maxDepth: number = 100
): RaySegment[] {
    const segments: RaySegment[] = [];

    function castRay(ray: Ray, depth: number) {
        const intersections = shapes.flatMap((shape) =>
            shape.intersect(ray).map((t) => ({ t, shape }))
        );
        const hit = findHit(intersections);
        if (!hit) {
            // No intersection: Find end point of line very far along the direction from mouse start to mouse end
            segments.push({
                start: ray.start,
                end: pointOnRay(ray, 10000),
                color: { r: 255, g: 255, b: 0 },
            });
            return;
        }
        const hitPoint = pointOnRay(ray, hit.t);
        const normalv = hit.shape.normalAt(hitPoint);
        const reflectv = reflect(ray.direction, normalv);
        const overPoint = vec_add(hitPoint, vec_mul(normalv, 0.001));
        segments.push({
            start: ray.start,
            end: hitPoint,
            color: { r: 255, g: 255, b: 0 },
        });
        ray = {
            start: overPoint,
            direction: reflectv,
        };
        if (depth < maxDepth) {
            castRay(ray, depth + 1);
        }
    }

    const fullDir = vec_sub(
        apply(laser.transform, newPoint(1, 0)),
        apply(laser.transform, newPoint(0, 0))
    );
    let ray = {
        start: apply(laser.transform, newPoint(0, 0)),
        direction: vec_normalize(fullDir),
    };
    castRay(ray, 0);

    return segments;
}

export function computeSegments(
    lasers: Laser[],
    shapes: Shape[]
): RaySegment[] {
    return lasers.flatMap((laser) => _computeSegments(laser, shapes));
}

/** The "hit" is the intersection with smallest non-negative t-value
 *  TODO: Keep intersection list sorted while inserting to optimise.
 **/
function findHit(intersections: Intersection[]): Intersection | null {
    const sorted = intersections.sort((a, b) => a.t - b.t);
    return sorted.find((x) => x.t >= 0) ?? null;
}

function reflect(inVec: Vec3, normal: Vec3) {
    return vec_sub(inVec, vec_mul(normal, 2 * vec_dot(inVec, normal)));
}

function pointOnRay(ray: Ray, t: number): Vec3 {
    return vec_add(ray.start, vec_mul(ray.direction, t));
}
