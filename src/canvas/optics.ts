/* This module handles the calculations of which ray segments should appear in the scene, given the locations
of light sources and objects. */

import {
    newPoint,
    vec_add,
    vec_dot,
    vec_mul,
    vec_normalize,
    vec_sub,
    type Vec3,
} from "../math";
import { Shape, type Intersection } from "../shapes";
import { color_add, color_mul, type Color } from "../shared/color";
import { apply } from "../transform";
import type { Eye, Ray } from "../types";

export interface RaySegment {
    start: Vec3;
    end: Vec3;
    color: Color;
    attenuation: number;
}

const BLACK: Color = { r: 0, g: 0, b: 0 };
let SCHLICK_ENABLED = true;

interface IntersectionData {
    t: number;
    shape: Shape;
    inside: boolean;
    point: Vec3;
    normalv: Vec3;
    eyev: Vec3;
    overPoint: Vec3;
    underPoint: Vec3;
    reflectv: Vec3;
    n1: number;
    n2: number;
}

/**
 * Returns all ray segments generated by the given laser.
 * This amounts to traversing a tree:
 * - The root node represents the laser source
 * - Leaf nodes represent the infinitely distant endpoints of segments that don't hit any shape
 * - All intermediate nodes represent the intersection of a segment with some shape in the scene.
 * It's a tree, not a list, because when a beam hits a surface it will typically generate (at least) one reflected
 * ray and (at least) one refracted ray, depending on the material properties.
 * Each edge (segment) needs to be appended to the return array. Its color depends on the color of its child edges,
 * and on the material properties of its child node (intersection point).
 * We avoid a recursive implementation because that would not translate well to a GPU version.
 *
 * Instead, we do two passes:
 * In pass 1, we generate the tree, moving downwards from the root node.
 * ... More to work out!
 * @param laser
 * @param shapes
 * @returns
 */
function _computeSegments(
    laser: Eye,
    shapes: Shape[],
    maxDepth: number = 10
): RaySegment[] {
    console.log(shapes);
    const fullDir = vec_sub(
        apply(laser.transform, newPoint(1, 0)),
        apply(laser.transform, newPoint(0, 0))
    );
    let ray = {
        start: apply(laser.transform, newPoint(0, 0)),
        direction: vec_normalize(fullDir),
    };
    return castRay(shapes, ray, maxDepth, 1);
}

function castRay(
    shapes: Shape[],
    ray: Ray,
    remaining: number,
    attenuation: number
): RaySegment[] {
    const intersections = shapes.flatMap((shape) =>
        shape.intersect(ray).map((t) => ({ t, shape }))
    );

    intersections.sort((a, b) => a.t - b.t);

    console.log(intersections);

    // The "hit" is the first intersection in front of the ray source.
    // If no hit, then there are no more segments along this path.
    const hit = intersections.find((x) => x.t >= 0);
    if (!hit) {
        return [];
    }

    const hitPoint = pointOnRay(ray, hit.t);

    const data = computeIntersectionData(hit, ray, intersections);

    // Shade hit
    const surface = data.shape.material.color; // TODO: Phong reflection model
    const reflected = castReflectedRay(shapes, data, remaining, attenuation);
    const refracted = castRefractedRay(shapes, data, remaining, attenuation);

    const reflectedColor = color_mul(
        reflected[0]?.color ?? BLACK,
        data.shape.material.reflectivity
    );
    const refractedColor = color_mul(
        refracted[0]?.color ?? BLACK,
        data.shape.material.transparency
    );

    let color;
    const material = data.shape.material;
    if (
        SCHLICK_ENABLED &&
        material.reflectivity > 0 &&
        material.transparency > 0
    ) {
        const reflectance = schlick(data);
        color = color_add(
            surface,
            color_add(
                color_mul(reflectedColor, reflectance),
                color_mul(refractedColor, 1 - reflectance)
            )
        );
    } else {
        color = color_add(surface, color_add(refractedColor, reflectedColor));
    }

    const firstSegment: RaySegment = {
        start: ray.start,
        end: hitPoint,
        color,
        attenuation,
    };
    return [firstSegment, ...reflected, ...refracted];
}

function castReflectedRay(
    shapes: Shape[],
    data: IntersectionData,
    remaining: number,
    attenuation: number
): RaySegment[] {
    if (remaining === 0 || data.shape.material.reflectivity === 0) {
        return [];
    }

    const ray: Ray = {
        start: data.overPoint,
        direction: data.reflectv,
    };
    return castRay(
        shapes,
        ray,
        remaining - 1,
        attenuation * data.shape.material.reflectivity
    );
}

function castRefractedRay(
    shapes: Shape[],
    data: IntersectionData,
    remaining: number,
    attenuation: number
): RaySegment[] {
    if (remaining === 0 || data.shape.material.transparency === 0) {
        // No refraction
        return [];
    }
    const { n1, n2, eyev, normalv, underPoint } = data;

    // Refractions
    const nRatio = n1 / n2;
    const cos_i = vec_dot(eyev, normalv);
    const sin2_t = nRatio * nRatio * (1 - cos_i * cos_i);
    if (sin2_t > 1) {
        // Total internal reflection
        return [];
    }

    const cos_t = Math.sqrt(1 - sin2_t);
    const refractv = vec_sub(
        vec_mul(normalv, nRatio * cos_i - cos_t),
        vec_mul(eyev, nRatio)
    );

    const refractedRay = {
        start: underPoint,
        direction: refractv,
    };

    return castRay(
        shapes,
        refractedRay,
        remaining - 1,
        attenuation * data.shape.material.transparency
    );
}

export function toggleSchlick() {
    SCHLICK_ENABLED = !SCHLICK_ENABLED;
}

/* Uses the Schlick reflectance model to return the fraction of light that should be reflected
on interface with a transparent materisl */
function schlick(data: IntersectionData) {
    // Find the cosine of the angle between the eye and normal vectors
    let cos = vec_dot(data.eyev, data.normalv);

    // Total internal reflection can only occur if n1 > n2
    if (data.n1 > data.n2) {
        const n = data.n1 / data.n2;
        const sin2_t = n * n * (1 - cos * cos);
        if (sin2_t > 1) {
            // Total internal reflection
            return 1;
        }

        cos = Math.sqrt(1 - sin2_t);
    }

    const r0 = Math.pow((data.n1 - data.n2) / (data.n1 + data.n2), 2);
    return r0 + (1 - r0) * Math.pow(1 - cos, 5);
}

function computeIntersectionData(
    hit: Intersection,
    ray: Ray,
    intersections: Intersection[]
): IntersectionData {
    const point = pointOnRay(ray, hit.t);
    let normalv = hit.shape.normalAt(point);
    const eyev = vec_mul(ray.direction, -1);
    const inside = vec_dot(eyev, normalv) < 0;

    if (inside) {
        normalv = vec_mul(normalv, -1);
    }

    const nudge = vec_mul(normalv, 0.001);
    const overPoint = vec_add(point, nudge);
    const underPoint = vec_sub(point, nudge);

    const reflectv = reflect(ray.direction, normalv);

    // Determine the refractive indexes of the two materials the ray is transitioning between.
    let n1 = 1.0;
    let n2 = 1.0;
    let containers: Shape[] = [];
    for (const x of intersections) {
        if (x === hit && containers.length > 0) {
            n1 = containers[containers.length - 1].material.refractiveIndex;
        }

        if (containers.includes(x.shape)) {
            containers = containers.filter((s) => s !== x.shape);
        } else {
            containers.push(x.shape);
        }

        if (x === hit && containers.length > 0) {
            n2 = containers[containers.length - 1].material.refractiveIndex;
        }
    }

    return {
        ...hit,
        point,
        eyev,
        normalv,
        inside,
        overPoint,
        underPoint,
        reflectv,
        n1,
        n2,
    };
}

export function computeSegments(lasers: Eye[], shapes: Shape[]): RaySegment[] {
    return lasers.flatMap((laser) => _computeSegments(laser, shapes));
}

function reflect(inVec: Vec3, normal: Vec3) {
    return vec_sub(inVec, vec_mul(normal, 2 * vec_dot(inVec, normal)));
}

function pointOnRay(ray: Ray, t: number): Vec3 {
    return vec_add(ray.start, vec_mul(ray.direction, t));
}
