/* This module handles the calculations of which ray segments should appear in the scene, given the locations
of light sources and objects. */

import {
    newPoint,
    vec_add,
    vec_dot,
    vec_mul,
    vec_normalize,
    vec_sub,
    type Vec3,
} from "../math";
import { Shape, type Intersection } from "../shapes";
import type { Color } from "../shared/color";
import { apply } from "../transform";
import type { Laser, Ray } from "../types";

export interface RaySegment {
    start: Vec3;
    end: Vec3;
    color: Color;
}

interface IntersectionData {
    t: number;
    shape: Shape;
    inside: boolean;
    point: Vec3;
    normalv: Vec3;
    eyev: Vec3;
    overPoint: Vec3;
    underPoint: Vec3;
    reflectv: Vec3;
    n1: number;
    n2: number;
}

/**
 * Returns all ray segments generated by the given laser.
 * This amounts to traversing a tree:
 * - The root node represents the laser source
 * - Leaf nodes represent the infinitely distant endpoints of segments that don't hit any shape
 * - All intermediate nodes represent the intersection of a segment with some shape in the scene.
 * It's a tree, not a list, because when a beam hits a surface it will typically generate (at least) one reflected
 * ray and (at least) one refracted ray, depending on the material properties.
 * Each edge (segment) needs to be appended to the return array. Its color depends on the color of its child edges,
 * and on the material properties of its child node (intersection point).
 * We avoid a recursive implementation because that would not translate well to a GPU version.
 *
 * Instead, we do two passes:
 * In pass 1, we generate the tree, moving downwards from the root node.
 * ... More to work out!
 * @param laser
 * @param shapes
 * @returns
 */
function _computeSegments(
    laser: Laser,
    shapes: Shape[],
    maxDepth: number = 10
): RaySegment[] {
    const segments: RaySegment[] = [];

    function castRay(ray: Ray, depth: number) {
        const intersections = shapes
            .flatMap((shape) => shape.intersect(ray).map((t) => ({ t, shape })))
            .sort((x) => x.t);

        // The "hit" is the first intersection in front of the ray source.
        const hit = intersections.find((x) => x.t >= 0);

        if (!hit) {
            // No intersection: Find end point of line very far along the direction from mouse start to mouse end
            segments.push({
                start: ray.start,
                end: pointOnRay(ray, 10000),
                color: { r: 255, g: 255, b: 0 },
            });
            return;
        }

        // Add this segment to the global array
        const hitPoint = pointOnRay(ray, hit.t);
        segments.push({
            start: ray.start,
            end: hitPoint,
            color: { r: 255, g: 255, b: 0 },
        });

        const { n1, n2, eyev, normalv, underPoint, overPoint, reflectv } =
            computeIntersectionData(hit, ray, intersections);

        // Refractions
        const nRatio = n1 / n2;
        const cos_i = vec_dot(eyev, normalv);
        const sin2_t = nRatio * nRatio * (1 - cos_i * cos_i);
        if (sin2_t > 1) {
            // Total internal reflection
            return;
        }

        const cos_t = Math.sqrt(1 - sin2_t);
        const refractv = vec_sub(
            vec_mul(normalv, nRatio * cos_i - cos_t),
            vec_mul(eyev, nRatio)
        );

        const refractedRay = {
            start: underPoint,
            direction: refractv,
        };

        const reflectedRay = {
            start: overPoint,
            direction: reflectv,
        };
        if (depth < maxDepth) {
            castRay(refractedRay, depth + 1);
            castRay(reflectedRay, depth + 1);
        }
    }

    const fullDir = vec_sub(
        apply(laser.transform, newPoint(1, 0)),
        apply(laser.transform, newPoint(0, 0))
    );
    let ray = {
        start: apply(laser.transform, newPoint(0, 0)),
        direction: vec_normalize(fullDir),
    };
    castRay(ray, 0);

    return segments;
}

function computeIntersectionData(
    hit: Intersection,
    ray: Ray,
    intersections: Intersection[]
): IntersectionData {
    const point = pointOnRay(ray, hit.t);
    let normalv = hit.shape.normalAt(point);
    const eyev = vec_mul(ray.direction, -1);
    const inside = vec_dot(eyev, normalv) < 0;

    if (inside) {
        normalv = vec_mul(normalv, -1);
    }

    const nudge = vec_mul(normalv, 0.001);
    const overPoint = vec_add(point, nudge);
    const underPoint = vec_sub(point, nudge);

    const reflectv = reflect(ray.direction, normalv);

    // Determine the refractive indexes of the two materials the ray is transitioning between.
    let n1 = 1.0;
    let n2 = 1.0;
    let containers: Shape[] = [];
    for (const x of intersections) {
        if (x === hit && containers.length > 0) {
            n1 = containers[containers.length - 1].material.refractiveIndex;
        }

        if (containers.includes(x.shape)) {
            containers = containers.filter((s) => s !== x.shape);
        } else {
            containers.push(x.shape);
        }

        if (x === hit && containers.length > 0) {
            n2 = containers[containers.length - 1].material.refractiveIndex;
        }
    }

    return {
        ...hit,
        point,
        eyev,
        normalv,
        inside,
        overPoint,
        underPoint,
        reflectv,
		n1,
		n2
    };
}

export function computeSegments(
    lasers: Laser[],
    shapes: Shape[]
): RaySegment[] {
    return lasers.flatMap((laser) => _computeSegments(laser, shapes));
}

function reflect(inVec: Vec3, normal: Vec3) {
    return vec_sub(inVec, vec_mul(normal, 2 * vec_dot(inVec, normal)));
}

function pointOnRay(ray: Ray, t: number): Vec3 {
    return vec_add(ray.start, vec_mul(ray.direction, t));
}
