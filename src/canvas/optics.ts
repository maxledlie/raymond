/* This module handles the calculations of which ray segments should appear in the scene, given the locations
of light sources and objects. */

import {
    newPoint,
    newVector,
    vec_add,
    vec_dot,
    vec_magnitude,
    vec_mul,
    vec_normalize,
    vec_sub,
    type Vec3,
} from "../math";
import { Shape, type Intersection } from "../shapes";
import {
    color_add,
    color_hadamard,
    color_mul,
    type Color,
} from "../shared/color";
import { apply, toObjectTransform } from "../transform";
import type { Ray } from "../types";
import { Eye } from "./Eye";
import type { PointLight } from "./PointLight";

export interface RaySegment {
    start: Vec3;
    end: Vec3;
    color: Color;
    attenuation: number;
    dashed?: boolean;
}

const BLACK: Color = { r: 0, g: 0, b: 0 };
let SCHLICK_ENABLED = true;
let doLogging = false;

interface IntersectionData {
    t: number;
    shape: Shape;
    inside: boolean;
    point: Vec3;
    normalv: Vec3;
    eyev: Vec3;
    overPoint: Vec3;
    underPoint: Vec3;
    reflectv: Vec3;
    n1: number;
    n2: number;
}

export function setLogging(logging: boolean) {
    doLogging = logging;
}

export interface OpticsResult {
    segments: RaySegment[];
    vision: Color[];
}

/**
 * Returns all ray segments generated by the given laser.
 * This amounts to traversing a tree:
 * - The root node represents the laser source
 * - Leaf nodes represent the infinitely distant endpoints of segments that don't hit any shape
 * - All intermediate nodes represent the intersection of a segment with some shape in the scene.
 * It's a tree, not a list, because when a beam hits a surface it will typically generate (at least) one reflected
 * ray and (at least) one refracted ray, depending on the material properties.
 * Each edge (segment) needs to be appended to the return array. Its color depends on the color of its child edges,
 * and on the material properties of its child node (intersection point).
 * @param eye
 * @param shapes
 * @returns
 */
export function computeSegments(
    eye: Eye,
    shapes: Shape[],
    lights: PointLight[],
    maxDepth: number = 10
): OpticsResult {
    if (doLogging) {
        console.log("Computing segments for eye: ", eye);
    }
    // Calculate initial rays
    const eyePos = apply(eye.transform, newPoint(0, 0));
    const eyeDir = vec_normalize(
        vec_sub(
            apply(eye.transform, newPoint(1, 0)),
            apply(eye.transform, newPoint(0, 0))
        )
    );
    const filmCentre = vec_add(eyePos, eyeDir);
    const filmParallel = newVector(eyeDir.y, -eyeDir.x);
    const halfWidth = Math.tan(eye.fov / 2);
    const pixelStep = (2 * halfWidth) / eye.numRays;
    const rays: Ray[] = [];

    // There's got to be a better way to do this, but it's 10pm and I'm tired.
    for (
        let i = -Math.floor(eye.numRays / 2);
        i < Math.floor(eye.numRays / 2) + 1;
        i++
    ) {
        const filmPos = vec_add(
            filmCentre,
            vec_mul(filmParallel, i * pixelStep)
        );
        rays.push({
            start: eyePos,
            direction: vec_normalize(vec_sub(filmPos, eyePos)),
        });
    }
    let allSegments: RaySegment[] = [];
    const vision: Color[] = [];
    for (const ray of rays) {
        const segments = castRay(shapes, lights, ray, maxDepth, 1);
        if (segments.length === 0) {
            vision.push(BLACK);
        } else {
            vision.push(segments[0].color);
        }
        allSegments = allSegments.concat(segments);
    }

    return {
        segments: allSegments,
        vision,
    };
}

function castRay(
    shapes: Shape[],
    lights: PointLight[],
    ray: Ray,
    remaining: number,
    attenuation: number
): RaySegment[] {
    const intersections = shapes.flatMap((shape) =>
        shape.intersect(ray).map((t) => ({ t, shape }))
    );

    intersections.sort((a, b) => a.t - b.t);

    // The "hit" is the first intersection in front of the ray source.
    // If no hit, then there are no more segments along this path.
    const hit = intersections.find((x) => x.t >= 0);
    if (!hit) {
        return [];
    }

    const hitPoint = pointOnRay(ray, hit.t);

    const data = computeIntersectionData(hit, ray, intersections);

    if (doLogging) {
        console.log("Intersection data:");
        console.log(data);
    }

    // Shade hit
    let surface = BLACK;
    for (const light of lights) {
        const shadowed = isShadowed(data.overPoint, shapes, light);
        surface = color_add(surface, lighting(data, light, shadowed));
    }
    surface = color_mul(surface, 1 - data.shape.material.transparency);
    const reflected = castReflectedRay(
        shapes,
        lights,
        data,
        remaining,
        attenuation
    );
    const refracted = castRefractedRay(
        shapes,
        lights,
        data,
        remaining,
        attenuation
    );

    const reflectedColor = color_mul(
        reflected[0]?.color ?? BLACK,
        data.shape.material.reflectivity
    );
    const refractedColor = color_mul(
        refracted[0]?.color ?? BLACK,
        data.shape.material.transparency
    );

    if (doLogging) {
        console.log("reflected color: ", reflectedColor);
        console.log("refracted color: ", refractedColor);
    }

    let color;
    const material = data.shape.material;

    if (
        SCHLICK_ENABLED &&
        material.reflectivity > 0 &&
        material.transparency > 0
    ) {
        const reflectance = schlick(data);
        color = color_add(
            surface,
            color_add(
                color_mul(reflectedColor, reflectance),
                color_mul(refractedColor, 1 - reflectance)
            )
        );
    } else {
        color = color_add(surface, color_add(refractedColor, reflectedColor));
    }

    const firstSegment: RaySegment = {
        start: ray.start,
        end: hitPoint,
        color,
        attenuation,
    };
    return [firstSegment, ...reflected, ...refracted];
}

function lighting(
    data: IntersectionData,
    light: PointLight,
    inShadow: boolean
): Color {
    const material = data.shape.material;
    const effectiveColor = color_hadamard(material.color, light.color);
    const o = toObjectTransform(light.transform);
    const lightPos = newPoint(o.translation.x, o.translation.y);
    if (doLogging) {
        console.log("lightPos: ", lightPos);
    }
    const lightv = vec_normalize(vec_sub(lightPos, data.point));
    const ambient = color_mul(effectiveColor, material.ambient);

    if (inShadow) {
        return ambient;
    }

    const lightDotNormal = vec_dot(lightv, data.normalv);
    let diffuse;
    let specular;
    if (lightDotNormal < 0) {
        diffuse = BLACK;
        specular = BLACK;
    } else {
        diffuse = color_mul(effectiveColor, material.diffuse * lightDotNormal);
        const reflectv = reflect(vec_mul(lightv, -1), data.eyev);
        const reflectDotEye = vec_dot(reflectv, data.eyev);

        if (reflectDotEye <= 0) {
            specular = BLACK;
        } else {
            const factor = Math.pow(reflectDotEye, material.shininess);
            specular = color_mul(light.color, material.specular * factor);
        }
    }
    return color_add(color_add(ambient, diffuse), specular);
}

function castReflectedRay(
    shapes: Shape[],
    lights: PointLight[],
    data: IntersectionData,
    remaining: number,
    attenuation: number
): RaySegment[] {
    if (remaining === 0 || data.shape.material.reflectivity === 0) {
        return [];
    }

    const ray: Ray = {
        start: data.overPoint,
        direction: data.reflectv,
    };
    return castRay(
        shapes,
        lights,
        ray,
        remaining - 1,
        attenuation * data.shape.material.reflectivity
    );
}

function castRefractedRay(
    shapes: Shape[],
    lights: PointLight[],
    data: IntersectionData,
    remaining: number,
    attenuation: number
): RaySegment[] {
    if (remaining === 0 || data.shape.material.transparency === 0) {
        // No refraction
        return [];
    }
    const { n1, n2, eyev, normalv, underPoint } = data;

    // Refractions
    const nRatio = n1 / n2;
    const cos_i = vec_dot(eyev, normalv);
    const sin2_t = nRatio * nRatio * (1 - cos_i * cos_i);
    if (sin2_t > 1) {
        // Total internal reflection
        return [];
    }

    const cos_t = Math.sqrt(1 - sin2_t);
    const refractv = vec_sub(
        vec_mul(normalv, nRatio * cos_i - cos_t),
        vec_mul(eyev, nRatio)
    );

    const refractedRay = {
        start: underPoint,
        direction: refractv,
    };

    return castRay(
        shapes,
        lights,
        refractedRay,
        remaining - 1,
        attenuation * data.shape.material.transparency
    );
}

export function toggleSchlick() {
    SCHLICK_ENABLED = !SCHLICK_ENABLED;
}

/* Uses the Schlick reflectance model to return the fraction of light that should be reflected
on interface with a transparent materisl */
function schlick(data: IntersectionData) {
    // Find the cosine of the angle between the eye and normal vectors
    let cos = vec_dot(data.eyev, data.normalv);

    // Total internal reflection can only occur if n1 > n2
    if (data.n1 > data.n2) {
        const n = data.n1 / data.n2;
        const sin2_t = n * n * (1 - cos * cos);
        if (sin2_t > 1) {
            // Total internal reflection
            return 1;
        }

        cos = Math.sqrt(1 - sin2_t);
    }

    const r0 = Math.pow((data.n1 - data.n2) / (data.n1 + data.n2), 2);
    return r0 + (1 - r0) * Math.pow(1 - cos, 5);
}

function computeIntersectionData(
    hit: Intersection,
    ray: Ray,
    intersections: Intersection[]
): IntersectionData {
    const point = pointOnRay(ray, hit.t);
    let normalv = hit.shape.normalAt(point);
    const eyev = vec_mul(ray.direction, -1);
    const inside = vec_dot(eyev, normalv) < 0;

    if (inside) {
        normalv = vec_mul(normalv, -1);
    }

    const nudge = vec_mul(normalv, 0.001);
    const overPoint = vec_add(point, nudge);
    const underPoint = vec_sub(point, nudge);

    const reflectv = reflect(ray.direction, normalv);

    // Determine the refractive indexes of the two materials the ray is transitioning between.
    let n1 = 1.0;
    let n2 = 1.0;
    let containers: Shape[] = [];
    for (const x of intersections) {
        if (x === hit && containers.length > 0) {
            n1 = containers[containers.length - 1].material.refractiveIndex;
        }

        if (containers.includes(x.shape)) {
            containers = containers.filter((s) => s !== x.shape);
        } else {
            containers.push(x.shape);
        }

        if (x === hit && containers.length > 0) {
            n2 = containers[containers.length - 1].material.refractiveIndex;
        }
    }

    return {
        ...hit,
        point,
        eyev,
        normalv,
        inside,
        overPoint,
        underPoint,
        reflectv,
        n1,
        n2,
    };
}

function reflect(inVec: Vec3, normal: Vec3) {
    return vec_sub(inVec, vec_mul(normal, 2 * vec_dot(inVec, normal)));
}

function pointOnRay(ray: Ray, t: number): Vec3 {
    return vec_add(ray.start, vec_mul(ray.direction, t));
}

/**
 * Returns whether or not the given point is in shadow w.r.t. the given point light source.
 */
function isShadowed(point: Vec3, shapes: Shape[], light: PointLight): boolean {
    const o = toObjectTransform(light.transform);
    const v = vec_sub(newPoint(o.translation.x, o.translation.y), point);
    const distance = vec_magnitude(v);
    const direction = vec_normalize(v);

    const ray: Ray = {
        start: point,
        direction,
    };

    const intersections = shapes.flatMap((shape) =>
        shape.intersect(ray).map((t) => ({ t, shape }))
    );

    intersections.sort((a, b) => a.t - b.t);
    const hit = intersections.find((x) => x.t >= 0);
    return hit != null && hit.t < distance;
}
